<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate icon" class="js-site-favicon" type="image/png" href="/blog/assets/favicon/favicon.ico">
  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="/blog/assets/favicon/favicon.ico">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Optimizing C/C++ Basic | State of the art</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Optimizing C/C++ Basic">
<meta name="author" content="Minh-Thanh Hoang">
<meta property="og:locale" content="en_US">
<meta name="description" content='1. Variable storage 1.1 Static storage 1.2 Register storage 2. Operators 2.1 Initializations 2.2 Contructor 2.3 Assignment composite 2.4 Operator rule 3. Booleans 4. Functions 4.1 Macro 4.2 Parameter 4.3 Function rule 5. Arrays 6. Loops 6.1 Unrolling 6.2 Copy and clearing arrays 6.3 Move loops inside function call 6.4 Fuction rule 7. Statements 7.1 Using table lookup 7.2 Switch and table 8. Input/Output Using perf to profiling in linux : (perf)[(http://www.brendangregg.com/perf.html)] 1. Variable storage 1.1 Static storage Version 1 : 7.1 cycles int main(){ int n = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } Version 2 : 6.1 B cycles int main(){ static int nStatic = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } static : replace calculation result by storing the value in static storage, where possible 1.2 Register storage Version 1 : 2.2 B cycles int main(){ static int nStatic = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nStatic; } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 1 B cycles int main(){ register int nRegister = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nRegister; } cout &lt;&lt; res &lt;&lt; endl; return 0; } register : variables stored in register are accessed in a flash, and number of registers is strictly limited 2. Operators 2.1 Initializations Version 1 : 17.7 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s; s = "Hello World"; } return 0; } Version 2 : 17 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s("Hello World"); } return 0; } Using initializations instead of assignments. In particular, in contructors, use initialization list 2.2 Contructor demoClass(const T&amp; t){ _data = t; } -&gt; demoClass(const T&amp; t) : _data(t){} 2.3 Assignment composite Version 1 : 8.8 B cycles int main(){ string hello = "Hello"; string world = "World"; for (int i = 0; i &lt; 10000000; i++){ string result = hello + " " + hello + "," + world; } return 0; } Version 2 : 4.7 B cycles int main(){ string hello = "Hello"; string world = "World"; for (int i = 0; i &lt; 10000000; i++){ string result = hello; result += " "; result += hello; result += ","; result += world; } return 0; } Use the assignment composite operators instead of simple operators combined with assignment operators 2.4 Operator rule Using prefix operator (++obj) instead of the postfix operator (obj++) in object; postfix operator will create a spectre copy Use shift operations &gt;&gt; and &lt;&lt; instead of integer multiplication and division if possible Should use the same type of variables for processing, type conversion must be avoid Replace integer division with multiplication when there are multiple divisions in an expression. Example : x = a / b / c; =&gt; x = a/(b * c); 3. Booleans Version 1 : 1.5 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (a &amp;&amp; i%2 == 0){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } Version 2 : 1.2 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (i%2 == 0 &amp;&amp; a){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } If one operator and is more predictable than the other, then put it first If one operator and is faster to calculate than the other then put it first The one operator and of the Boolean operators &amp;&amp; is evaluated in the following way If the first operand of &amp;&amp; is false, then the seconds operand is not evaluated at all because the result is known to be false regardless of the value of the second operand. 4. Functions 4.1 Macro Use macros instead of functions Version 1 int findMax(int a, int b){ return (a &gt; b) ? a : b; } int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = findMax(i, 10000); } } Version 2 : 3 times faster #define FINDMAX(a, b) (a &gt; b ? a : b) int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = FINDMAX(i, 10000); } } 4.2 Parameter Version 1 : 7 B cycles int res = 0; void sum(vector&lt;int&gt; arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 2 B cycles int res = 0; void sum(vector&lt;int&gt; &amp;arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Pass structures or classes by reference, not by value Using C scanf or printf instead of C++ cin or cout 4.3 Function rule Return objects via reference parameters (The return value of a function will be stored in a register. If this return data has no intened usage, time and space are wasted in storing this information) template &lt;class T&gt; T funcReturn(){ T res; ... return res; } =&gt; template &lt;class T&gt; T funcReturn(T&amp; res){ res = ... } 5. Arrays Accessing in continuous memory is faster than discrete memory or random memory 6. Loops 6.1 Unrolling Version 1 : 13 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 6.1 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i += 3){ functionA(); functionB(); functionC(); } return 0; } Using unrolling 6.2 Copy and clearing arrays Version 1 : 15B cycles int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; for (int j = 0; j &lt; 1000; j++) a[j] = value; for (int j = 0; j &lt; 1000; j++) b[j] = a[j]; } return 0; } Version 2 : 1B cycles (15 times faster) #include &lt;stdio.h&gt; #include &lt;string&gt; int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; memset(a, value, sizeof(a)); memcpy(b, a, sizeof(a)); } return 0; } Using memcpy, memset is often faster 6.3 Move loops inside function call Version 1 : 8.3 B cycles int res = 0; void functionA(){ res++; } int main(){ for (int i = 0; i &lt; 10000000; i++){ functionA(); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 7.6 B cycles int res = 0; void functionA(){ for (int i = 0; i &lt; 10000000; i++) res++; } int main(){ functionA(); cout &lt;&lt; res &lt;&lt; endl; return 0; } Using for loop inside function call 6.4 Fuction rule It is faster to compare to zero rather than compare with difference number Prefix (++i) is better than postfix(i++) Avoid calculation in condition of loop 7. Statements 7.1 Using table lookup Version 1 : 1B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; for (int i = 0; i &lt; 10000000; i++){ a[i] = b[i] ? 100 : 200; } return 0; } Version 2 : 0.7B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; int value[2] = {200, 100}; for (int i = 0; i &lt; 10000000; i++){ a[i] = value[b[i]]; } return 0; } 7.2 Switch and table Version 1 : 7B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 3.2B cycles void functionA(){}; void functionB(){}; void functionC(){}; typedef void(*func)(void); int main(){ static func functions[] = {functionA, functionB, functionC}; for (int i = 0; i &lt; 10000000; i++){ functions[i % 3](); } return 0; } Switch can be replace by a function table Using switch instead of if 8. Input/Output Read file on the buffer and read and write multiple time on buffer to avoid access multiple time read write on disk.'>
<meta property="og:description" content='1. Variable storage 1.1 Static storage 1.2 Register storage 2. Operators 2.1 Initializations 2.2 Contructor 2.3 Assignment composite 2.4 Operator rule 3. Booleans 4. Functions 4.1 Macro 4.2 Parameter 4.3 Function rule 5. Arrays 6. Loops 6.1 Unrolling 6.2 Copy and clearing arrays 6.3 Move loops inside function call 6.4 Fuction rule 7. Statements 7.1 Using table lookup 7.2 Switch and table 8. Input/Output Using perf to profiling in linux : (perf)[(http://www.brendangregg.com/perf.html)] 1. Variable storage 1.1 Static storage Version 1 : 7.1 cycles int main(){ int n = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } Version 2 : 6.1 B cycles int main(){ static int nStatic = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } static : replace calculation result by storing the value in static storage, where possible 1.2 Register storage Version 1 : 2.2 B cycles int main(){ static int nStatic = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nStatic; } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 1 B cycles int main(){ register int nRegister = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nRegister; } cout &lt;&lt; res &lt;&lt; endl; return 0; } register : variables stored in register are accessed in a flash, and number of registers is strictly limited 2. Operators 2.1 Initializations Version 1 : 17.7 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s; s = "Hello World"; } return 0; } Version 2 : 17 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s("Hello World"); } return 0; } Using initializations instead of assignments. In particular, in contructors, use initialization list 2.2 Contructor demoClass(const T&amp; t){ _data = t; } -&gt; demoClass(const T&amp; t) : _data(t){} 2.3 Assignment composite Version 1 : 8.8 B cycles int main(){ string hello = "Hello"; string world = "World"; for (int i = 0; i &lt; 10000000; i++){ string result = hello + " " + hello + "," + world; } return 0; } Version 2 : 4.7 B cycles int main(){ string hello = "Hello"; string world = "World"; for (int i = 0; i &lt; 10000000; i++){ string result = hello; result += " "; result += hello; result += ","; result += world; } return 0; } Use the assignment composite operators instead of simple operators combined with assignment operators 2.4 Operator rule Using prefix operator (++obj) instead of the postfix operator (obj++) in object; postfix operator will create a spectre copy Use shift operations &gt;&gt; and &lt;&lt; instead of integer multiplication and division if possible Should use the same type of variables for processing, type conversion must be avoid Replace integer division with multiplication when there are multiple divisions in an expression. Example : x = a / b / c; =&gt; x = a/(b * c); 3. Booleans Version 1 : 1.5 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (a &amp;&amp; i%2 == 0){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } Version 2 : 1.2 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (i%2 == 0 &amp;&amp; a){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } If one operator and is more predictable than the other, then put it first If one operator and is faster to calculate than the other then put it first The one operator and of the Boolean operators &amp;&amp; is evaluated in the following way If the first operand of &amp;&amp; is false, then the seconds operand is not evaluated at all because the result is known to be false regardless of the value of the second operand. 4. Functions 4.1 Macro Use macros instead of functions Version 1 int findMax(int a, int b){ return (a &gt; b) ? a : b; } int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = findMax(i, 10000); } } Version 2 : 3 times faster #define FINDMAX(a, b) (a &gt; b ? a : b) int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = FINDMAX(i, 10000); } } 4.2 Parameter Version 1 : 7 B cycles int res = 0; void sum(vector&lt;int&gt; arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 2 B cycles int res = 0; void sum(vector&lt;int&gt; &amp;arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Pass structures or classes by reference, not by value Using C scanf or printf instead of C++ cin or cout 4.3 Function rule Return objects via reference parameters (The return value of a function will be stored in a register. If this return data has no intened usage, time and space are wasted in storing this information) template &lt;class T&gt; T funcReturn(){ T res; ... return res; } =&gt; template &lt;class T&gt; T funcReturn(T&amp; res){ res = ... } 5. Arrays Accessing in continuous memory is faster than discrete memory or random memory 6. Loops 6.1 Unrolling Version 1 : 13 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 6.1 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i += 3){ functionA(); functionB(); functionC(); } return 0; } Using unrolling 6.2 Copy and clearing arrays Version 1 : 15B cycles int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; for (int j = 0; j &lt; 1000; j++) a[j] = value; for (int j = 0; j &lt; 1000; j++) b[j] = a[j]; } return 0; } Version 2 : 1B cycles (15 times faster) #include &lt;stdio.h&gt; #include &lt;string&gt; int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; memset(a, value, sizeof(a)); memcpy(b, a, sizeof(a)); } return 0; } Using memcpy, memset is often faster 6.3 Move loops inside function call Version 1 : 8.3 B cycles int res = 0; void functionA(){ res++; } int main(){ for (int i = 0; i &lt; 10000000; i++){ functionA(); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 7.6 B cycles int res = 0; void functionA(){ for (int i = 0; i &lt; 10000000; i++) res++; } int main(){ functionA(); cout &lt;&lt; res &lt;&lt; endl; return 0; } Using for loop inside function call 6.4 Fuction rule It is faster to compare to zero rather than compare with difference number Prefix (++i) is better than postfix(i++) Avoid calculation in condition of loop 7. Statements 7.1 Using table lookup Version 1 : 1B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; for (int i = 0; i &lt; 10000000; i++){ a[i] = b[i] ? 100 : 200; } return 0; } Version 2 : 0.7B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; int value[2] = {200, 100}; for (int i = 0; i &lt; 10000000; i++){ a[i] = value[b[i]]; } return 0; } 7.2 Switch and table Version 1 : 7B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 3.2B cycles void functionA(){}; void functionB(){}; void functionC(){}; typedef void(*func)(void); int main(){ static func functions[] = {functionA, functionB, functionC}; for (int i = 0; i &lt; 10000000; i++){ functions[i % 3](); } return 0; } Switch can be replace by a function table Using switch instead of if 8. Input/Output Read file on the buffer and read and write multiple time on buffer to avoid access multiple time read write on disk.'>
<link rel="canonical" href="http://hmthanh.github.io/blog/tutorial/2020/11/17/optimized-cplusplus-basic.html">
<meta property="og:url" content="http://hmthanh.github.io/blog/tutorial/2020/11/17/optimized-cplusplus-basic.html">
<meta property="og:site_name" content="State of the art">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-11-17T11:04:17+07:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Optimizing C/C++ Basic">
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Optimizing C/C++ Basic","dateModified":"2020-11-17T11:04:17+07:00","datePublished":"2020-11-17T11:04:17+07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://hmthanh.github.io/blog/tutorial/2020/11/17/optimized-cplusplus-basic.html"},"url":"http://hmthanh.github.io/blog/tutorial/2020/11/17/optimized-cplusplus-basic.html","author":{"@type":"Person","name":"Minh-Thanh Hoang"},"description":"1. Variable storage 1.1 Static storage 1.2 Register storage 2. Operators 2.1 Initializations 2.2 Contructor 2.3 Assignment composite 2.4 Operator rule 3. Booleans 4. Functions 4.1 Macro 4.2 Parameter 4.3 Function rule 5. Arrays 6. Loops 6.1 Unrolling 6.2 Copy and clearing arrays 6.3 Move loops inside function call 6.4 Fuction rule 7. Statements 7.1 Using table lookup 7.2 Switch and table 8. Input/Output Using perf to profiling in linux : (perf)[(http://www.brendangregg.com/perf.html)] 1. Variable storage 1.1 Static storage Version 1 : 7.1 cycles int main(){ int n = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } Version 2 : 6.1 B cycles int main(){ static int nStatic = 10000000; for (int i = 0; i &lt; n; i++){ } return 0; } static : replace calculation result by storing the value in static storage, where possible 1.2 Register storage Version 1 : 2.2 B cycles int main(){ static int nStatic = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nStatic; } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 1 B cycles int main(){ register int nRegister = 3; long res = 0; for (int i = 0; i &lt; 10000000; i++){ res += i * nRegister; } cout &lt;&lt; res &lt;&lt; endl; return 0; } register : variables stored in register are accessed in a flash, and number of registers is strictly limited 2. Operators 2.1 Initializations Version 1 : 17.7 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s; s = &quot;Hello World&quot;; } return 0; } Version 2 : 17 B cycles int main(){ for (int i = 0; i &lt; 10000000; i++){ string s(&quot;Hello World&quot;); } return 0; } Using initializations instead of assignments. In particular, in contructors, use initialization list 2.2 Contructor demoClass(const T&amp; t){ _data = t; } -&gt; demoClass(const T&amp; t) : _data(t){} 2.3 Assignment composite Version 1 : 8.8 B cycles int main(){ string hello = &quot;Hello&quot;; string world = &quot;World&quot;; for (int i = 0; i &lt; 10000000; i++){ string result = hello + &quot; &quot; + hello + &quot;,&quot; + world; } return 0; } Version 2 : 4.7 B cycles int main(){ string hello = &quot;Hello&quot;; string world = &quot;World&quot;; for (int i = 0; i &lt; 10000000; i++){ string result = hello; result += &quot; &quot;; result += hello; result += &quot;,&quot;; result += world; } return 0; } Use the assignment composite operators instead of simple operators combined with assignment operators 2.4 Operator rule Using prefix operator (++obj) instead of the postfix operator (obj++) in object; postfix operator will create a spectre copy Use shift operations &gt;&gt; and &lt;&lt; instead of integer multiplication and division if possible Should use the same type of variables for processing, type conversion must be avoid Replace integer division with multiplication when there are multiple divisions in an expression. Example : x = a / b / c; =&gt; x = a/(b * c); 3. Booleans Version 1 : 1.5 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (a &amp;&amp; i%2 == 0){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } Version 2 : 1.2 B cycles int main(){ long res = 0; for (int i = 0; i &lt; 10000000; i++){ bool a = true; if (i%2 == 0 &amp;&amp; a){ res++; } } cout &lt;&lt; res &lt;&lt; endl; } If one operator and is more predictable than the other, then put it first If one operator and is faster to calculate than the other then put it first The one operator and of the Boolean operators &amp;&amp; is evaluated in the following way If the first operand of &amp;&amp; is false, then the seconds operand is not evaluated at all because the result is known to be false regardless of the value of the second operand. 4. Functions 4.1 Macro Use macros instead of functions Version 1 int findMax(int a, int b){ return (a &gt; b) ? a : b; } int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = findMax(i, 10000); } } Version 2 : 3 times faster #define FINDMAX(a, b) (a &gt; b ? a : b) int main(){ long res = 0; for (int i = 0; i &lt; 1000000; i++){ int t = FINDMAX(i, 10000); } } 4.2 Parameter Version 1 : 7 B cycles int res = 0; void sum(vector&lt;int&gt; arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 2 B cycles int res = 0; void sum(vector&lt;int&gt; &amp;arr){ for (int i = 0; i &lt; arr.size(); i++) res += arr[i]; } int main(){ vector&lt;int&gt; v(10, 1); for (int i = 0; i &lt; 10000000; i++){ sum(v); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Pass structures or classes by reference, not by value Using C scanf or printf instead of C++ cin or cout 4.3 Function rule Return objects via reference parameters (The return value of a function will be stored in a register. If this return data has no intened usage, time and space are wasted in storing this information) template &lt;class T&gt; T funcReturn(){ T res; ... return res; } =&gt; template &lt;class T&gt; T funcReturn(T&amp; res){ res = ... } 5. Arrays Accessing in continuous memory is faster than discrete memory or random memory 6. Loops 6.1 Unrolling Version 1 : 13 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 6.1 B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i += 3){ functionA(); functionB(); functionC(); } return 0; } Using unrolling 6.2 Copy and clearing arrays Version 1 : 15B cycles int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; for (int j = 0; j &lt; 1000; j++) a[j] = value; for (int j = 0; j &lt; 1000; j++) b[j] = a[j]; } return 0; } Version 2 : 1B cycles (15 times faster) #include &lt;stdio.h&gt; #include &lt;string&gt; int main(){ int a[1000], b[1000]; for (int i = 0; i &lt; 10000000; i++){ int value = i % 100; memset(a, value, sizeof(a)); memcpy(b, a, sizeof(a)); } return 0; } Using memcpy, memset is often faster 6.3 Move loops inside function call Version 1 : 8.3 B cycles int res = 0; void functionA(){ res++; } int main(){ for (int i = 0; i &lt; 10000000; i++){ functionA(); } cout &lt;&lt; res &lt;&lt; endl; return 0; } Version 2 : 7.6 B cycles int res = 0; void functionA(){ for (int i = 0; i &lt; 10000000; i++) res++; } int main(){ functionA(); cout &lt;&lt; res &lt;&lt; endl; return 0; } Using for loop inside function call 6.4 Fuction rule It is faster to compare to zero rather than compare with difference number Prefix (++i) is better than postfix(i++) Avoid calculation in condition of loop 7. Statements 7.1 Using table lookup Version 1 : 1B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; for (int i = 0; i &lt; 10000000; i++){ a[i] = b[i] ? 100 : 200; } return 0; } Version 2 : 0.7B cycles int main(){ vector&lt;int&gt; a = vector&lt;int&gt;(4, 0); vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false}; int value[2] = {200, 100}; for (int i = 0; i &lt; 10000000; i++){ a[i] = value[b[i]]; } return 0; } 7.2 Switch and table Version 1 : 7B cycles void functionA(){}; void functionB(){}; void functionC(){}; int main(){ for (int i = 0; i &lt; 10000000; i++){ int funcIdx = i % 3; switch(funcIdx){ default: case 0: functionA(); break; case 1: functionB(); break; case 2: functionC(); break; } } return 0; } Version 2 : 3.2B cycles void functionA(){}; void functionB(){}; void functionC(){}; typedef void(*func)(void); int main(){ static func functions[] = {functionA, functionB, functionC}; for (int i = 0; i &lt; 10000000; i++){ functions[i % 3](); } return 0; } Switch can be replace by a function table Using switch instead of if 8. Input/Output Read file on the buffer and read and write multiple time on buffer to avoid access multiple time read write on disk.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css">
<link type="application/atom+xml" rel="alternate" href="http://hmthanh.github.io/blog/feed.xml" title="State of the art">
</head>
<body>
    <main class="page-content" aria-label="Content">
    <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

            <header class="post-header">
                <h1 class="post-title p-name" itemprop="name headline" id="title">Optimizing C/C++ Basic</h1>
                <a class="back" href="/blog/"><svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"></path></svg>Back Home</a>
                <p class="post-meta">
                    <time class="dt-published" datetime="2020-11-17T11:04:17+07:00" itemprop="datePublished">Nov 17, 2020
            </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Minh-Thanh Hoang</span></span></p>
                    <div style="clear:both"></div>
            </header>
            

            <div class="post-content e-content" itemprop="articleBody">
                <ul class="table-of-content" id="markdown-toc">
  <li>
<a href="#1-variable-storage" id="markdown-toc-1-variable-storage">1. Variable storage</a>    <ul>
      <li><a href="#11-static-storage" id="markdown-toc-11-static-storage">1.1 Static storage</a></li>
      <li><a href="#12-register-storage" id="markdown-toc-12-register-storage">1.2 Register storage</a></li>
    </ul>
  </li>
  <li>
<a href="#2-operators" id="markdown-toc-2-operators">2. Operators</a>    <ul>
      <li><a href="#21-initializations" id="markdown-toc-21-initializations">2.1 Initializations</a></li>
      <li><a href="#22-contructor" id="markdown-toc-22-contructor">2.2 Contructor</a></li>
      <li><a href="#23-assignment-composite" id="markdown-toc-23-assignment-composite">2.3 Assignment composite</a></li>
      <li><a href="#24-operator-rule" id="markdown-toc-24-operator-rule">2.4 Operator rule</a></li>
    </ul>
  </li>
  <li><a href="#3-booleans" id="markdown-toc-3-booleans">3. Booleans</a></li>
  <li>
<a href="#4-functions" id="markdown-toc-4-functions">4. Functions</a>    <ul>
      <li><a href="#41-macro" id="markdown-toc-41-macro">4.1 Macro</a></li>
      <li><a href="#42-parameter" id="markdown-toc-42-parameter">4.2 Parameter</a></li>
      <li><a href="#43-function-rule" id="markdown-toc-43-function-rule">4.3 Function rule</a></li>
    </ul>
  </li>
  <li><a href="#5-arrays" id="markdown-toc-5-arrays">5. Arrays</a></li>
  <li>
<a href="#6-loops" id="markdown-toc-6-loops">6. Loops</a>    <ul>
      <li><a href="#61-unrolling" id="markdown-toc-61-unrolling">6.1 Unrolling</a></li>
      <li><a href="#62-copy-and-clearing-arrays" id="markdown-toc-62-copy-and-clearing-arrays">6.2 Copy and clearing arrays</a></li>
      <li><a href="#63-move-loops-inside-function-call" id="markdown-toc-63-move-loops-inside-function-call">6.3 Move loops inside function call</a></li>
      <li><a href="#64-fuction-rule" id="markdown-toc-64-fuction-rule">6.4 Fuction rule</a></li>
    </ul>
  </li>
  <li>
<a href="#7-statements" id="markdown-toc-7-statements">7. Statements</a>    <ul>
      <li><a href="#71-using-table-lookup" id="markdown-toc-71-using-table-lookup">7.1 Using table lookup</a></li>
      <li><a href="#72-switch-and-table" id="markdown-toc-72-switch-and-table">7.2 Switch and table</a></li>
    </ul>
  </li>
  <li><a href="#8-inputoutput" id="markdown-toc-8-inputoutput">8. Input/Output</a></li>
</ul>

<p>Using perf to profiling in linux : (perf)[(http://www.brendangregg.com/perf.html)]</p>

<h1 id="1-variable-storage">1. Variable storage</h1>

<h3 id="11-static-storage">1.1 Static storage</h3>

<ul>
  <li>
    <p>Version 1 : 7.1 cycles</p>

    <pre><code class="language-c++">int main(){
  int n = 10000000;
  for (int i = 0; i &lt; n; i++){
  }
  return 0;
}
</code></pre>
  </li>
  <li>
    <p>Version 2 : 6.1 B cycles</p>

    <pre><code class="language-c++">int main(){
  static int nStatic = 10000000;
  for (int i = 0; i &lt; n; i++){
  }
  return 0;
}
</code></pre>
  </li>
</ul>

<blockquote>
  <p><code>static</code> : replace calculation result by storing the value in static storage, where possible</p>
</blockquote>

<h3 id="12-register-storage">1.2 Register storage</h3>

<ul>
  <li>
    <p>Version 1 : 2.2 B cycles</p>

    <pre><code class="language-c++">int main(){
  static int nStatic = 3;
  long res = 0;
  for (int i = 0; i &lt; 10000000; i++){
    res += i * nStatic;
  }
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>
  </li>
  <li>
    <p>Version 2 : 1 B cycles</p>

    <pre><code class="language-c++">int main(){
  register int nRegister = 3;
  long res = 0;
  for (int i = 0; i &lt; 10000000; i++){
    res += i * nRegister;
  }
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>
  </li>
</ul>

<blockquote>
  <p><code>register</code> : variables stored in register are accessed in a flash, and number of registers is strictly limited</p>
</blockquote>

<h1 id="2-operators">2. Operators</h1>

<h3 id="21-initializations">2.1 Initializations</h3>

<ul>
  <li>
    <p>Version 1 : 17.7 B cycles</p>

    <pre><code class="language-c++">int main(){
  for (int i = 0; i &lt; 10000000; i++){
    string s;
    s = "Hello World";
  }
  return 0;
}
</code></pre>
  </li>
  <li>
    <p>Version 2 : 17 B cycles</p>

    <pre><code class="language-c++">int main(){
  for (int i = 0; i &lt; 10000000; i++){
    string s("Hello World");
  }
  return 0;
}
</code></pre>
  </li>
</ul>

<blockquote>
  <p>Using initializations instead of assignments. In particular, in contructors, use initialization list</p>
</blockquote>

<h3 id="22-contructor">2.2 Contructor</h3>

<pre><code class="language-c++">demoClass(const T&amp; t){
  _data = t;
}
</code></pre>

<p>-&gt;</p>

<pre><code class="language-c++">demoClass(const T&amp; t) : _data(t){}
</code></pre>

<h3 id="23-assignment-composite">2.3 Assignment composite</h3>

<ul>
  <li>
    <p>Version 1 : 8.8 B cycles</p>

    <pre><code class="language-c++">int main(){
  string hello = "Hello";
  string world = "World";

  for (int i = 0; i &lt; 10000000; i++){
    string result = hello + " " + hello + "," + world;
  }
  return 0;
}
</code></pre>
  </li>
  <li>
    <p>Version 2 : 4.7 B cycles</p>

    <pre><code class="language-c++">int main(){
  string hello = "Hello";
  string world = "World";

  for (int i = 0; i &lt; 10000000; i++){
    string result = hello;
    result += " ";
    result += hello;
    result += ",";
    result += world;
  }
  return 0;
}
</code></pre>
  </li>
</ul>

<blockquote>
  <p>Use the assignment composite operators instead of simple operators combined with assignment operators</p>
</blockquote>

<h3 id="24-operator-rule">2.4 Operator rule</h3>

<blockquote>
  <ul>
    <li>Using prefix operator (<code>++obj</code>) instead of the postfix operator (<code>obj++</code>) in object; postfix operator will create a spectre copy</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>Use shift operations <code>&gt;&gt;</code> and <code>&lt;&lt;</code> instead of integer multiplication and division if possible</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>Should use the same type of variables for processing, type conversion must be avoid</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>Replace integer division with multiplication when there are multiple divisions in an expression. Example : <code>x = a / b / c;</code>  =&gt; <code>x = a/(b * c);</code>
</li>
  </ul>
</blockquote>

<h1 id="3-booleans">3. Booleans</h1>

<ul>
  <li>Version 1 : 1.5 B cycles</li>
</ul>

<pre><code class="language-c++">int main(){
  long res = 0;
  for (int i = 0; i &lt; 10000000; i++){
    bool a = true;
    if (a &amp;&amp; i%2 == 0){
      res++;
    }
  }

  cout &lt;&lt; res &lt;&lt; endl;
}
</code></pre>

<ul>
  <li>Version 2 : 1.2 B cycles</li>
</ul>

<pre><code class="language-c++">int main(){
  long res = 0;
  for (int i = 0; i &lt; 10000000; i++){
    bool a = true;
    if (i%2 == 0 &amp;&amp; a){
      res++;
    }
  }

  cout &lt;&lt; res &lt;&lt; endl;
}
</code></pre>

<blockquote>
  <ul>
    <li>If one operator <code>and</code> is more predictable than the other, then put it first</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>If one operator <code>and</code> is faster to calculate than the other then put it first</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>The one operator <code>and</code> of the Boolean operators <code>&amp;&amp;</code> is evaluated in the following way</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>If the first operand of <code>&amp;&amp;</code> is false, then the seconds operand is not evaluated at all because the result is known to be false regardless of the value of the second operand.</li>
  </ul>
</blockquote>

<h1 id="4-functions">4. Functions</h1>

<h3 id="41-macro">4.1 Macro</h3>

<p>Use macros instead of functions</p>

<ul>
  <li>Version 1</li>
</ul>

<pre><code class="language-c++">int findMax(int a, int b){
  return (a &gt; b) ? a : b;
}

int main(){
  long res = 0;
  for (int i = 0; i &lt; 1000000; i++){
    int t = findMax(i, 10000);
  }
}
</code></pre>

<ul>
  <li>Version 2 : 3 times faster</li>
</ul>

<pre><code class="language-c++">#define FINDMAX(a, b) (a &gt; b ? a : b)

int main(){
  long res = 0;
  for (int i = 0; i &lt; 1000000; i++){
    int t = FINDMAX(i, 10000);
  }
}
</code></pre>

<h3 id="42-parameter">4.2 Parameter</h3>

<ul>
  <li>Version 1 : 7 B cycles</li>
</ul>

<pre><code class="language-c++">int res = 0;
void sum(vector&lt;int&gt; arr){
  for (int i = 0; i &lt; arr.size(); i++)
    res += arr[i];
}

int main(){
  vector&lt;int&gt; v(10, 1);
  for (int i = 0; i &lt; 10000000; i++){
    sum(v);
  }
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 2 B cycles</li>
</ul>

<pre><code class="language-c++">int res = 0;
void sum(vector&lt;int&gt; &amp;arr){
  for (int i = 0; i &lt; arr.size(); i++)
    res += arr[i];
}

int main(){
  vector&lt;int&gt; v(10, 1);
  for (int i = 0; i &lt; 10000000; i++){
    sum(v);
  }
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>

<blockquote>
  <p>Pass structures or classes by reference, not by value</p>
</blockquote>

<blockquote>
  <p>Using C <code>scanf</code> or <code>printf</code> instead of C++ <code>cin</code> or <code>cout</code></p>
</blockquote>

<h3 id="43-function-rule">4.3 Function rule</h3>

<blockquote>
  <ul>
    <li>Return objects via reference parameters
(The return value of a function will be stored in a register. If this return data has no intened usage, time and space are wasted in storing this information)</li>
  </ul>
</blockquote>

<pre><code class="language-c++">template &lt;class T&gt; T funcReturn(){
  T res;
  ...
  return res;
}
</code></pre>
<p>=&gt;</p>
<pre><code class="language-c++">template &lt;class T&gt; T funcReturn(T&amp; res){
  res = ...
}
</code></pre>

<h1 id="5-arrays">5. Arrays</h1>

<blockquote>
  <p>Accessing in continuous memory is faster than discrete memory or random memory</p>
</blockquote>

<h1 id="6-loops">6. Loops</h1>

<h3 id="61-unrolling">6.1 Unrolling</h3>

<ul>
  <li>Version 1 : 13 B cycles</li>
</ul>

<pre><code class="language-c++">void functionA(){};
void functionB(){};
void functionC(){};

int main(){
  for (int i = 0; i &lt; 10000000; i++){
    int funcIdx = i % 3;
    switch(funcIdx){
      default: case 0: functionA(); break;
      case 1: functionB(); break;
      case 2: functionC(); break;
    }
  }

  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 6.1 B cycles</li>
</ul>

<pre><code class="language-c++">void functionA(){};
void functionB(){};
void functionC(){};

int main(){
  for (int i = 0; i &lt; 10000000; i += 3){
    functionA();
    functionB();
    functionC();
  }

  return 0;
}
</code></pre>

<blockquote>
  <p>Using unrolling</p>
</blockquote>

<h3 id="62-copy-and-clearing-arrays">6.2 Copy and clearing arrays</h3>

<ul>
  <li>Version 1 : 15B cycles</li>
</ul>

<pre><code class="language-c++">int main(){
  int a[1000], b[1000];
  for (int i = 0; i &lt; 10000000; i++){
    int value = i % 100;
    for (int j = 0; j &lt; 1000; j++)
      a[j] = value;

    for (int j = 0; j &lt; 1000; j++)
      b[j] = a[j];
  }

  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 1B cycles (15 times faster)</li>
</ul>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string&gt;
int main(){
  int a[1000], b[1000];
  for (int i = 0; i &lt; 10000000; i++){
    int value = i % 100;
    memset(a, value, sizeof(a));
    memcpy(b, a, sizeof(a));
  }

  return 0;
}
</code></pre>

<blockquote>
  <p>Using <code>memcpy</code>, <code>memset</code> is often faster</p>
</blockquote>

<h3 id="63-move-loops-inside-function-call">6.3 Move loops inside function call</h3>

<ul>
  <li>Version 1 : 8.3 B cycles</li>
</ul>

<pre><code class="language-c++">int res = 0;
void functionA(){
  res++;
}
int main(){
  for (int i = 0; i &lt; 10000000; i++){
    functionA();
  }
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 7.6 B cycles</li>
</ul>

<pre><code class="language-c++">int res = 0;
void functionA(){
  for (int i = 0; i &lt; 10000000; i++)
    res++;
}
int main(){
  functionA();
  cout &lt;&lt; res &lt;&lt; endl;
  return 0;
}
</code></pre>

<blockquote>
  <p>Using for loop inside function call</p>
</blockquote>

<h3 id="64-fuction-rule">6.4 Fuction rule</h3>

<blockquote>
  <p>It is faster to compare to zero rather than compare with difference number</p>
</blockquote>

<blockquote>
  <p>Prefix (<code>++i</code>) is better than postfix(<code>i++</code>)</p>
</blockquote>

<blockquote>
  <p>Avoid calculation in condition of loop</p>
</blockquote>

<h1 id="7-statements">7. Statements</h1>

<h3 id="71-using-table-lookup">7.1 Using table lookup</h3>

<ul>
  <li>Version 1 : 1B cycles</li>
</ul>

<pre><code class="language-c++">int main(){
  vector&lt;int&gt; a = vector&lt;int&gt;(4, 0);
  vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false};
  for (int i = 0; i &lt; 10000000; i++){
    a[i] = b[i] ? 100 : 200;
  }
  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 0.7B cycles</li>
</ul>

<pre><code class="language-c++">int main(){
  vector&lt;int&gt; a = vector&lt;int&gt;(4, 0);
  vector&lt;bool&gt; b = vector&lt;bool&gt;{true, false, true, false};
  int value[2] = {200, 100};
  for (int i = 0; i &lt; 10000000; i++){
    a[i] = value[b[i]];
  }
  return 0;
}
</code></pre>

<h3 id="72-switch-and-table">7.2 Switch and table</h3>

<ul>
  <li>Version 1 : 7B cycles</li>
</ul>

<pre><code class="language-c++">void functionA(){};
void functionB(){};
void functionC(){};

int main(){
  for (int i = 0; i &lt; 10000000; i++){
    int funcIdx = i % 3;
    switch(funcIdx){
      default: case 0: functionA(); break;
      case 1: functionB(); break;
      case 2: functionC(); break;
    }
  }

  return 0;
}
</code></pre>

<ul>
  <li>Version 2 : 3.2B cycles</li>
</ul>

<pre><code class="language-c++">void functionA(){};
void functionB(){};
void functionC(){};

typedef void(*func)(void);

int main(){
  static func functions[] = {functionA, functionB, functionC};
  for (int i = 0; i &lt; 10000000; i++){
    functions[i % 3]();
  }

  return 0;
}
</code></pre>

<blockquote>
  <p>Switch can be replace by a function table</p>
</blockquote>

<blockquote>
  <p>Using <code>switch</code> instead of <code>if</code></p>
</blockquote>

<h1 id="8-inputoutput">8. Input/Output</h1>

<blockquote>
  <p>Read file on the buffer and read and write multiple time on buffer to avoid access multiple time read write on disk.</p>
</blockquote>

            </div>
<a class="u-url" href="/blog/tutorial/2020/11/17/optimized-cplusplus-basic.html" hidden></a>
        </article>
        

        <div class="page-navigation">
          
          <a class="prev" href="/blog/tutorial/2020/11/01/basic-neovim.html"><svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"></path></svg> NeoVim cơ bản</a>  
      </div>
    
    </div>
</main>
<div class="scroll-top"><a href="#title" class="nav-top">Top <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 320 512"><path d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"></path></svg></a></div>
<footer class="site-footer h-card">
    <data class="u-url" href="/blog/"></data>

    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div><ul class="social-media-list">
<li><a href="http://hmthanh.github.io/" target="_blank"><svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M336.5 160C322 70.7 287.8 8 248 8s-74 62.7-88.5 152h177zM152 256c0 22.2 1.2 43.5 3.3 64h185.3c2.1-20.5 3.3-41.8 3.3-64s-1.2-43.5-3.3-64H155.3c-2.1 20.5-3.3 41.8-3.3 64zm324.7-96c-28.6-67.9-86.5-120.4-158-141.6 24.4 33.8 41.2 84.7 50 141.6h108zM177.2 18.4C105.8 39.6 47.8 92.1 19.3 160h108c8.7-56.9 25.5-107.8 49.9-141.6zM487.4 192H372.7c2.1 21 3.3 42.5 3.3 64s-1.2 43-3.3 64h114.6c5.5-20.5 8.6-41.8 8.6-64s-3.1-43.5-8.5-64zM120 256c0-21.5 1.2-43 3.3-64H8.6C3.2 212.5 0 233.8 0 256s3.2 43.5 8.6 64h114.6c-2-21-3.2-42.5-3.2-64zm39.5 96c14.5 89.3 48.7 152 88.5 152s74-62.7 88.5-152h-177zm159.3 141.6c71.4-21.2 129.4-73.7 158-141.6h-108c-8.8 56.9-25.6 107.8-50 141.6zM19.3 352c28.6 67.9 86.5 120.4 158 141.6-24.4-33.8-41.2-84.7-50-141.6h-108z"></path></svg><span class="username">Website</span></a></li>
<li><a href="mailto:hmthanhgm@gmail.com"><svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg> <span class="username">Email</span></a></li>
<li><a href="https://www.facebook.com/hmthanhgm" target="_blank"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">Facebook</span></a></li>
<li><a href="https://github.com/hmthanh" target="_blank"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg>
    <span class="username">Github</span></a></li>
<li><a href="https://www.twitter.com/hmthanhgm" target="_blank"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Twitter</span></a></li>
<li>
        <a href="/blog/%20/feed.xml">RSS</a>
    </li>

</ul></div>
            <p>© 2020 Minh-Thanh</p>
        </div>
    </div>
</footer>
            <script>
                window.onload = function () {
                    var script = document.createElement('script');
                    var firstScript = document.getElementsByTagName('script')[0];
                    script.type = 'text/javascript';
                    script.async = true;
                    script.src = '/blog/sw-register.js?v=' + Date.now();
                    firstScript.parentNode.insertBefore(script, firstScript);
                };
            </script>
            </body>


</html>
